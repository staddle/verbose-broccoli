/**
 * 
 * autogenerated by solidity-visual-auditor
 * 
 * execute with: 
 *  #> truffle test <path/to/this/test.js>
 * 
 * */
const broccoli = artifacts.require("../contracts/broccoli.sol");
const truffleAssert = require('truffle-assertions');
const assert = require('assert');

const generateSampleItem = () => {
    return {
        id: 0,
        seller: "0x0000000000000000000000000000000000000000",
        buyer: "0x0000000000000000000000000000000000000000",
        name: "testName",
        description: "testDescription",
        price: "100000000000000000", //0.1eth
        image: "https://picsum.photos/seed/1/200",
        category: 1,
        subCategory: 1,
        timestamp: 1646929727992,
        runtime: 10 * 60 * 60 * 1000,
        deposit: 0,
    };
};

contract('broccoli', (accounts) => {
    const creatorAddress = accounts[0];
    const firstOwnerAddress = accounts[1];
    const secondOwnerAddress = accounts[2];
    const externalAddress = accounts[3];
    const secondExternalAddress = accounts[4];
    /* create named accounts for contract roles */
    const initialCut = 10;
    const initialMinimumDepositRatio = 50;

    before(async() => {
        /* before tests */
    })

    beforeEach(async() => {
        /* before each context */
    })

    context('when deployed', () => {
        it('should be owned by the creator account', () => {
            return broccoli.deployed()
                .then(instance => {
                    return instance.owner.call();
                })
                .then(result => {
                    assert.equal(result, creatorAddress, "Owner should be creator");
                });
        });
        it('should be not paused', () => {
            return broccoli.deployed()
                .then(instance => {
                    return instance.paused.call();
                })
                .then(result => {
                    assert.equal(result, false, "Contract should not be paused");
                });
        });
        it('should have initialCut as cut', () => {
            return broccoli.deployed()
                .then(instance => {
                    return instance.cut.call();
                })
                .then(result => {
                    assert.equal(result.toNumber(), initialCut, "Cut should be initialCut");
                });
        });
        it('should have initialMinimumDepositRatio as minimumDepositRatio', () => {
            return broccoli.deployed()
                .then(instance => {
                    return instance.minimumDepositRatio.call();
                })
                .then(result => {
                    assert.equal(result.toNumber(), initialMinimumDepositRatio, "MinimumDepositRatio should be initialMinimumDepositRatio");
                });
        });
    });

    context('when trying to pass ownership', () => {
        it('should restrict firstOwnerAddress to call onlyOwner functions', () => {
            return broccoli.deployed()
                .then(async instance => {
                    await truffleAssert.reverts(
                        instance.setCut(initialCut, {from: firstOwnerAddress}),
                        "Ownable: caller is not the owner");
                })
        });
        it('should transfer ownership to firstOwnerAddress', () => {
            let brocc;
            return broccoli.deployed()
                .then(instance => {
                    brocc = instance;
                    return brocc.transferOwnership(firstOwnerAddress, {from: creatorAddress});
                })
                .then(() => {
                    return brocc.owner.call();
                })
                .then(result => {
                    assert.equal(result, firstOwnerAddress, "Owner should be firstOwnerAddress");
                });
        });
        it('should now allow firstOwnerAddress to call onlyOwner functions', () => {
            return broccoli.deployed()
                .then(async instance => {
                    await truffleAssert.passes(
                        instance.setCut(initialCut, {from: firstOwnerAddress}),
                        "Should be able to call setCut from firstOwnerAddress if owner.");
                });
        });
    });

    context('when trying to pause and unpause the contract', () => {
        it('should not be paused at the start', () => {
            return broccoli.deployed()
                .then(instance => {
                    return instance.paused.call();
                })
                .then(result => {
                    assert.equal(result, false, "Contract should not be paused");
                });
        });
        it('should not be possible to unpause when its already not paused', () => {
            return broccoli.deployed()
                .then(async instance => {
                    await truffleAssert.reverts(
                        instance.unpause({from: firstOwnerAddress}),
                        "Pausable: not paused");
                });
        });
        it('should not be possible to pause from a non-owner address', () => {
            return broccoli.deployed()
                .then(async instance => {
                    await truffleAssert.reverts(
                        instance.pause({from: secondOwnerAddress}),
                        "Ownable: caller is not the owner");
                });
        });
        it('should be able to be paused by the owner', () => {
            let brocc;
            return broccoli.deployed()
                .then(async instance => {
                    brocc = instance;
                    await truffleAssert.passes(
                        brocc.pause( {from: firstOwnerAddress} ), 
                        "Should be able to pause the contract by the owner");
                })
                .then(async () => {
                    return brocc.paused.call();
                })
                .then(result => {
                    assert.equal(result, true, "Contract should be paused but was: " + result);
                });
        });
        it('should not be possible to interact with the contract when paused', () => {
            let brocc;
            return broccoli.deployed()
                .then(async instance => {
                    brocc = instance;
                    await truffleAssert.reverts(
                        brocc.setCut(120, {from: firstOwnerAddress}), 
                        "Pausable: paused");
                });
        });
        it('should not be possible to pause when its already paused', () => {
            return broccoli.deployed()
                .then(async instance => {
                    await truffleAssert.reverts(
                        instance.pause({from: firstOwnerAddress}),
                        "Pausable: paused");
                });
        });
        it('should not be possible to unpause from a non-owner address', () => {
            return broccoli.deployed()
                .then(async instance => {
                    await truffleAssert.reverts(
                        instance.unpause({from: secondOwnerAddress}),
                        "Ownable: caller is not the owner");
                });
        });
        it('should be possible to unpause the contract when it is paused', () => {
            return broccoli.deployed()
                .then(async instance => {
                    await truffleAssert.passes(
                        instance.unpause({from: firstOwnerAddress}),
                        "Should be able to unpause the contract by the owner"
                    );
                });
        });
        it('should now be possible to call functions again', () => {
            return broccoli.deployed()
                .then(async instance => {
                    await truffleAssert.passes(
                        instance.setCut(initialCut, {from: firstOwnerAddress}),
                        "Should be able to call setCut again.");
                });
        });
    });

    context('when trying to modify parameters', () => {
        it('should not be possible to modify cut with invalid value', () => {
            let brocc;
            return broccoli.deployed()
                .then(async instance => {
                    brocc = instance;
                    await truffleAssert.passes(
                        brocc.setCut(0, {from: firstOwnerAddress}),
                        "Cut should be settable to 0");
                })
                .then(async () => {
                    await truffleAssert.passes(
                        brocc.setCut(100, {from: firstOwnerAddress}),
                        "Cut should be settable to 100");
                })
                .then(async () => {
                    await truffleAssert.reverts(
                        brocc.setCut(101, {from: firstOwnerAddress}));
                })
                .then(async () => {
                    await brocc.setCut(initialCut, {from: firstOwnerAddress}); //set back to initial value
                });
        });
        it('should not be possible to modify minimumDepositRatio with invalid value', () => {
            let brocc;
            return broccoli.deployed()
                .then(async instance => {
                    brocc = instance;
                    await truffleAssert.passes(
                        brocc.setMinimumDepositRatio(0, {from: firstOwnerAddress}),
                        "minimumDepositRatio should be settable to 0 (0% deposit)")
                })
                .then(async () => {
                    await truffleAssert.passes(
                        brocc.setMinimumDepositRatio(100, {from: firstOwnerAddress}),
                        "minimumDepositRatio should be settable to 100 (100% deposit)");
                })
                .then(async () => {
                    await truffleAssert.reverts(
                        brocc.setMinimumDepositRatio(101, {from: firstOwnerAddress}));
                })
                .then(async () => {
                    await brocc.setMinimumDepositRatio(initialMinimumDepositRatio, {from: firstOwnerAddress}); //set back to initial value
                });
        });
    });

    context('when adding an item to the database', () => {
        const item = generateSampleItem();
        it('should be possible to add an item', () => {
            let brocc;
            return broccoli.deployed()
                .then(async instance => {
                    brocc = instance;
                    await truffleAssert.passes(
                        brocc.addItem(item.name, 
                            item.description, 
                            item.price,
                            item.image,
                            item.category,
                            item.subCategory,
                            item.timestamp,
                            item.runtime,
                            {from: externalAddress, value: "50000000000000000"}),
                        "Should be able to add an item.");
                })
                .then(async () => {
                    return brocc.getItem.call(1);
                })
                .then(result => {
                    assert.equal(result[0], 1, "ID should be 1, but was: " + result[0]);
                    assert.equal(result[1], externalAddress, "Seller should be " + externalAddress + " but was: " + result[1]);
                    assert.equal(result[2], "0x0000000000000000000000000000000000000000", "Buyer should be the zero address but was: " + result[2]);
                    assert.equal(result[3], "testName", "Name should be testName but was: " + result[3]);
                    assert.equal(result[4], "testDescription", "Description should be testDescription but was: " + result[4]);
                    assert.equal(result[5], "100000000000000000", "Price should be 100000000000000000 but was: " + result[5]);
                    assert.equal(result[6], "https://picsum.photos/seed/1/200", "Image should be https://picsum.photos/seed/1/200 but was: " + result[6]);
                    assert.equal(result[7], 1, "Category should be 1 but was: " + result[7]);
                    assert.equal(result[8], 1, "SubCategory should be 1 but was: " + result[8]);
                    assert.equal(result[9], 1646929727992, "Timestamp should be 1646929727992 but was: " + result[9]);
                    assert.equal(result[10], 36000000, "Runtime should be 36000000 (10h) but was: " + result[10]);
                    assert.equal(result[11], "50000000000000000", "Deposit should be 50000000000000000 but was " + result[11]);
                    assert.equal(result[12], "0", "received should be false but was " + result[12]);
                })
        });
        it('should have increased the numItems variable', () => {
            return broccoli.deployed()
                .then(instance => {
                    return instance.numItems.call();
                })
                .then(result => {
                    assert.equal(result.toNumber(), 1, "numItems should be 1");
                });
        });
        it('should have been added to itemsOnSale', () => {
            let brocc;
            return broccoli.deployed()
                .then(instance => {
                    brocc = instance;
                    return brocc.itemsOnSale.call(0);
                })
                .then(result => {
                    assert.equal(result, "1", "item should be on in itemsOnSale array, but was: " + result);
                    return brocc.getItemsOnSale.call();
                })
                .then(result => {
                    assert.equal(result.length, 1, "1 item should be in itemOnSale array, but it were: " + result.length);
                    assert.equal(result[0][0], "1", "id of item should be 1 but was" + result[0][0]);
                });
        });
        it('should not be possible to add an item without deposit', () => {
            let brocc;
            return broccoli.deployed()
                .then(async instance => {
                    brocc = instance;
                    await truffleAssert.reverts(
                        brocc.addItem(item.name, 
                            item.description, 
                            item.price,
                            item.image,
                            item.category,
                            item.subCategory,
                            item.timestamp,
                            item.runtime,
                            {from: externalAddress}));
                });
        });
        it('should not be possible to add an item with insufficient deposit', () => {
            let brocc;
            return broccoli.deployed()
                .then(async instance => {
                    brocc = instance;
                    await truffleAssert.reverts(
                        brocc.addItem(item.name, 
                            item.description, 
                            item.price,
                            item.image,
                            item.category,
                            item.subCategory,
                            item.timestamp,
                            item.runtime,
                            {from: externalAddress, value: "49999999999999999"}));
                });
        });
    });

    context('when buying an item', () => {
        const item = generateSampleItem();
        it('should have a withdraw amount of 0 for the seller before buying', () => {
            let brocc;
            return broccoli.deployed()
                .then(instance => {
                    brocc = instance;
                    return brocc.getPendingWithdrawal.call({from: externalAddress});
                })
                .then(result => {
                    assert.equal(result, 0, "Withdrawal should be 0");
                });
        });
        it('should be possible to buy an item', () => {
            let brocc;
            return broccoli.deployed()
                .then(async instance => {
                    brocc = instance;
                    await truffleAssert.passes(
                        brocc.buyItem(1, {from: secondExternalAddress, value: "100000000000000000"}),
                        "Should be able to buy an item.");
                });
        });
        it('should still not give seller any pending withdrawals', () => {
            let brocc;
            return broccoli.deployed()
                .then(instance => {
                    brocc = instance;
                    return brocc.getPendingWithdrawal.call({ from: externalAddress });
                })
                .then(result => {
                    assert.equal(result, 0, "Withdrawal should be 0 if not marked as received yet");
                });
        });
        it('should have been added to itemsOnHold', () => {
            let brocc;
            return broccoli.deployed()
                .then(instance => {
                    brocc = instance;
                    return brocc.itemsOnHold.call(0);
                })
                .then(result => {
                    assert.equal(result, "1", "item should be on in itemsOnHold array, but was: " + result);
                    return brocc.getItemsOnHold.call();
                })
                .then(result => {
                    assert.equal(result.length, 1, "1 item should be in itemsOnHold array, but it were: " + result.length);
                    assert.equal(result[0][0], "1", "id of item should be 1 but was" + result[0][0]);
                });
        });
        it('should not be possible to mark the item as received from other addresses than the buyers', () => {
            let brocc;
            return broccoli.deployed()
                .then(async instance => {
                    brocc = instance;
                    await truffleAssert.reverts(
                        brocc.markItemAsReceived(1, {from: externalAddress})); //e.g. from the seller
                });
        });
        it('should be possible to mark the item as received', () => {
            let brocc;
            return broccoli.deployed()
                .then(async instance => {
                    brocc = instance;
                    await truffleAssert.passes(
                        brocc.markItemAsReceived(1, { from: secondExternalAddress }),
                        "Should be able to mark an item as received from the buyer.");
                });
        });
        it('should have a withdraw amount ready for the seller after marking as received', () => {
            let brocc;
            return broccoli.deployed()
                .then(instance => {
                    brocc = instance;
                    return brocc.getPendingWithdrawal.call({ from: externalAddress });
                })
                .then(result => {
                    //Price 0.1 ETH, cut of 10%, deposit of 50% = 0.05 ETH
                    const expectedWithdrawal = web3.utils.toWei((0.1*0.9 + 0.05).toString());
                    assert.equal(result, expectedWithdrawal, 
                        "Withdrawal should be "+ expectedWithdrawal + " wei, but was " + result + " wei");
                });
        });
    });

    context('when withdrawing', () => {
        it('should be possible to withdraw', () => {
            let brocc;
            return broccoli.deployed()
                .then(async instance => {
                    brocc = instance;
                    await truffleAssert.passes(
                        brocc.withdraw({from: externalAddress }),
                        "Should be able to withdraw.");
                });
        });
        it('should not be possible to withdraw twice', () => {
            let brocc;
            return broccoli.deployed()
                .then(async instance => {
                    brocc = instance;
                    await truffleAssert.reverts(
                        brocc.withdraw({from: externalAddress}));
                });
        });
    });

    context('when donating', () => {
        it('should be possible to donate to the store', () => {
            let brocc;
            return broccoli.deployed()
                .then(async instance => {
                    brocc = instance;
                    await truffleAssert.passes(
                        brocc.send(web3.utils.toWei("1", "ether"), {from: externalAddress}),
                        "Should be able to donate.");
                });
        }); 
    });

    context('when selling 2 items and buying one', () => {
        const item = generateSampleItem();
        it('should only return deposit+price of one item to the seller', () => {
            let brocc;
            return broccoli.deployed()
                .then(async instance => {
                    brocc = instance;
                    await brocc.addItem(item.name, 
                        item.description, 
                        item.price,
                        item.image,
                        item.category,
                        item.subCategory,
                        item.timestamp,
                        item.runtime,
                        {from: externalAddress, value: "50000000000000000"});
                })
                .then(async () => {
                    await brocc.addItem(item.name, 
                        item.description, 
                        item.price,
                        item.image,
                        item.category,
                        item.subCategory,
                        item.timestamp,
                        item.runtime,
                        {from: externalAddress, value: "50000000000000000"});
                })
                .then(async () => {
                    await brocc.buyItem(2, {from: secondExternalAddress, value: "100000000000000000"});
                })
                .then(async () => {
                    await brocc.markItemAsReceived(2, {from: secondExternalAddress});
                })
                .then(() => {
                    return brocc.getPendingWithdrawal.call({ from: externalAddress });
                })
                .then(result => {
                    assert.equal(result, web3.utils.toWei("0.14", "ether"), "Withdrawal should be 0.14 ETH, but was " + result);
                });
        });
    });
});